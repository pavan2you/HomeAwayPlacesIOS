//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: com/homeaway/homeawayplaces/presenters/MapPresenter.java
//
//

#import "MarkerModel.h"
#import "Place.h"
#import "Strings.h"
#import "MapPresenter.h"
#import "IMapView.h"

@implementation MapPresenter

static int MapPresenter_DEFAULT_MAP_BOUNDS_PADDING_;

@synthesize mLocationApi = mLocationApi_;
@synthesize mIsMapLoading = mIsMapLoading_;
@synthesize mVeryFirstLoading = mVeryFirstLoading_;
@synthesize mMapAdjusted = mMapAdjusted_;
@synthesize mMarkerModelList = mMarkerModelList_;
@synthesize mCenter = mCenter_;
@synthesize mWaitingToRenderModel = mWaitingToRenderModel_;
@synthesize mVisibleRegionLocations = mVisibleRegionLocations_;
@synthesize mMarkers = mMarkers_;
@synthesize mPendingCameraZoomUpdateLatLng = mPendingCameraZoomUpdateLatLng_;
@synthesize mCameraOperationInProgress = mCameraOperationInProgress_;
@synthesize mCurrentZoomLevel = mCurrentZoomLevel_;
@synthesize mCurrentTransaction = mCurrentTransaction_;
@synthesize mPoiClickMessage = mPoiClickMessage_;

+ (int)DEFAULT_MAP_BOUNDS_PADDING {
  return MapPresenter_DEFAULT_MAP_BOUNDS_PADDING_;
}

+ (void)setDEFAULT_MAP_BOUNDS_PADDINGWithInt:(int)DEFAULT_MAP_BOUNDS_PADDING {
  MapPresenter_DEFAULT_MAP_BOUNDS_PADDING_ = DEFAULT_MAP_BOUNDS_PADDING;
}

- (id)initWithIMapView:(id<IMapView>)view {
  return [super initWithId:view];
}

- (void)loadWithWithIGenericList:(id<IGenericList>)places
              withVanilaLocation:(VanilaLocation *)center {
  mCenter_ = center;
  mMarkerModelList_ = ((id<IGenericList>) [mMobilePlatformFactory_ newList]);
  [mMarkerModelList_ addWithId:[[MarkerModel alloc] initWithVanilaLocation:center]];
  if (places != nil && [places size] > 0) {
    {
      for (NSObject* loopObj in places) {
      
        Place *place = ((Place *) loopObj);
        [mMarkerModelList_ addWithId:[[MarkerModel alloc] initWithPlace:place]];
      }
    }
  }
}

- (void)onCreate {
  [super onCreate];
  mVisibleRegionLocations_ = ((id<IGenericList>) [mMobilePlatformFactory_ newList]);
  mMarkers_ = ((id<IGenericList>) [mMobilePlatformFactory_ newList]);
  mVeryFirstLoading_ = YES;
  mIsMapLoading_ = YES;
  mLocationApi_ = [mMobilePlatformFactory_ getLocationApi];
  mWaitingToRenderModel_ = YES;
  mCurrentZoomLevel_ = MapPresenter_DEFAULT_MAP_ZOOM_LEVEL;
  [((id<IMapView>) ((id<IMapView>) [self getView])) setCallbacksListenerWithIVanilaMapCallbacks:self];
  MobilePlatformInfo *mpi = ((MobilePlatformInfo *) [mMobilePlatformFactory_ getPlatformInfo]);
  MapPresenter_DEFAULT_MAP_BOUNDS_PADDING_ = (int) (100 * mpi.deviceResolutionDpi);
  mPoiClickMessage_ = [self getStringWithNSString:[Strings map_poi_click_message]];
}

- (void)onDependenciesResolved {
  [super onDependenciesResolved];
  if (!mIsMapLoading_) {
    [self showMapOrInfo];
  }
}

- (void)onMapNotAvailable {
  [((id<IMapView>) ((id<IMapView>) [self getView])) showInfoMessageWithNSString:@"please get google play services!"];
}

- (void)onMapAvailable {
  mIsMapLoading_ = NO;
  if (mCurrentTransaction_ != nil) {
    return;
  }
  [self setUpMap];
  if (mWaitingToRenderModel_) {
    mWaitingToRenderModel_ = NO;
    if (!mVeryFirstLoading_) {
      [self bindDataModelWithIGenericList:mMarkerModelList_];
    }
  }
}

- (BOOL)isMapLoading {
  return mIsMapLoading_;
}

- (void)setUpMap {
  [((id<IMapView>) ((id<IMapView>) [self getView])) setUpMapWithTypeWithInt:IVanilaMap_MAP_TYPE_NORMAL];
  [((id<IMapView>) ((id<IMapView>) [self getView])) clearMap];
  [((id<IMapView>) ((id<IMapView>) [self getView])) animateCameraWithVanilaLocation:mCenter_ withFloat:MapPresenter_DEFAULT_MAP_ZOOM_LEVEL];
}

- (void)onMapLoaded {
  [self moveToWithIGenericList:mVisibleRegionLocations_];
}

- (void)onAnimationComplete {
  if (mPendingCameraZoomUpdateLatLng_ != nil) {
    [((id<IMapView>) ((id<IMapView>) [self getView])) animateCameraToLocationWithVanilaLocation:mPendingCameraZoomUpdateLatLng_];
    mPendingCameraZoomUpdateLatLng_ = nil;
  }
}

- (void)onCameraMove {
}

- (void)onAnimationCancel {
  [((id<IMapView>) ((id<IMapView>) [self getView])) handleAnyNativeChangesDueToAnimationCancel];
}

- (void)onCameraMoveStarted {
  mCameraOperationInProgress_ = YES;
}

- (void)onCameraPositionChangeWithFloat:(float)zoom {
  mCurrentZoomLevel_ = zoom;
  if (mCurrentTransaction_ != nil) {
    [mCurrentTransaction_ commit];
  }
  else if (mVeryFirstLoading_) {
    mVeryFirstLoading_ = NO;
    mMapAdjusted_ = NO;
  }
  mCameraOperationInProgress_ = NO;
}

- (void)resetMap {
  [((id<IMapView>) ((id<IMapView>) [self getView])) stopAnimation];
  [((id<IMapView>) ((id<IMapView>) [self getView])) clearMap];
  if (mMarkers_ == nil) {
    mMarkers_ = ((id<IGenericList>) [mMobilePlatformFactory_ newList]);
  }
  else {
    [mVisibleRegionLocations_ clear];
    {
      for (NSObject* loopObj in mMarkers_) {
      
        id<IMarker> m = ((id<IMarker>) loopObj);
        [m remove];
      }
    }
    [mMarkers_ clear];
  }
}

- (void)showMapOrInfo {
  if ([mMarkerModelList_ isEmpty]) {
    [((id<IMapView>) ((id<IMapView>) [self getView])) showInfoMessageWithNSString:@"No places available"];
  }
  else {
    [self bindDataModelWithIGenericList:mMarkerModelList_];
  }
}

- (void)bindDataModelWithIGenericList:(id<IGenericList>)list {
  if (mIsMapLoading_) {
    mWaitingToRenderModel_ = YES;
    return;
  }
  if (list == nil || [list size] == 0) {
    return;
  }
  mCurrentTransaction_ = [[MapPresenter_MapTransaction alloc] initWithMapPresenter:self withIGenericList:list];
  mCurrentTransaction_.animateCamera = YES;
  mMapAdjusted_ = NO;
  {
    for (NSObject* loopObj in list) {
    
      MarkerModel *model = ((MarkerModel *) loopObj);
      [self bindMarkerWithMarkerModel:model withMapPresenter_MapTransaction:mCurrentTransaction_];
    }
  }
  [self fixMapBoundsWithMapPresenter_MapTransaction:mCurrentTransaction_];
}

- (void)bindMarkerWithMarkerModel:(MarkerModel *)model
  withMapPresenter_MapTransaction:(MapPresenter_MapTransaction *)transaction {
  id<IMarkerOptions> markerOptions = [model newMarkerOptions];
  if (markerOptions == nil) {
    return;
  }
  id<IMarker> memberMarker = [((id<IMapView>) ((id<IMapView>) [self getView])) addNewOrCachedMarkerWithMarkerModel:model withIMarkerOptions:markerOptions];
  [memberMarker setVisibleWithBOOL:YES];
  if (![mMarkers_ containsWithId:memberMarker]) {
    [mMarkers_ addWithId:memberMarker];
    [memberMarker setTagWithId:model];
  }
  if (![transaction.placeMarkers containsWithId:memberMarker]) {
    [transaction.placeMarkers addWithId:memberMarker];
    [transaction.visiblePlaceLocations addWithId:[model getLocation]];
  }
}

- (void)fixMapBoundsWithMapPresenter_MapTransaction:(MapPresenter_MapTransaction *)transaction {
  mVisibleRegionLocations_ = transaction.visiblePlaceLocations;
  if (!mMapAdjusted_ || transaction.animateCamera) {
    [self moveToWithIGenericList:mVisibleRegionLocations_];
  }
  else {
    [transaction commit];
  }
  [((id<IMapView>) ((id<IMapView>) [self getView])) notifyModelRefreshComplete];
}

- (void)moveToWithIGenericList:(id<IGenericList>)modelLocations {
  if (modelLocations == nil) {
    return;
  }
  @try {
    if ([modelLocations size] > 1) {
      id<ILatLngBounds> latLngBounds = [mLocationApi_ newLatLngBounds];
      {
        for (NSObject* loopObj in modelLocations) {
        
          VanilaLocation *latLng = ((VanilaLocation *) loopObj);
          [latLngBounds includeWithVanilaLocation:latLng];
        }
      }
      [latLngBounds build];
      [self moveToWithVanilaLocation:[latLngBounds getCenter]];
    }
    else if ([modelLocations size] == 1) {
      [self moveToWithVanilaLocation:((VanilaLocation *) [modelLocations getWithInt:0])];
    }
    else {
      [self moveToWithVanilaLocation:(VanilaLocation *) nil];
    }
  }
  @catch (VanilaException *e) {
    NSLog(@"%@", [NSThread callStackSymbols]);
  }
}

- (void)moveToWithVanilaLocation:(VanilaLocation *)latLng {
  if (!mMapAdjusted_) {
    [self fixMapToVisibleModelBoundsWithVanilaLocation:latLng];
    mMapAdjusted_ = YES;
  }
  else if (latLng != nil) {
    [((id<IMapView>) ((id<IMapView>) [self getView])) animateCameraWithVanilaLocation:latLng withFloat:mCurrentZoomLevel_];
  }
}

- (BOOL)fixMapToVisibleModelBoundsWithVanilaLocation:(VanilaLocation *)latLng {
  if (mMarkers_ == nil || [mMarkers_ size] == 0) {
    return NO;
  }
  id<ILatLngBounds> bounds = [mLocationApi_ newLatLngBounds];
  int pointsCounter = 0;
  id<IGenericList> markers = mMarkers_;
  {
    for (NSObject* loopObj in markers) {
    
      id<IMarker> marker = ((id<IMarker>) loopObj);
      VanilaLocation *current = [marker getPosition];
      if (current == nil) {
        continue;
      }
      pointsCounter++;
      [bounds includeWithVanilaLocation:current];
    }
  }
  if (pointsCounter == 0) {
    return NO;
  }
  [bounds build];
  if (latLng == nil) {
    latLng = [bounds getCenter];
    mPendingCameraZoomUpdateLatLng_ = latLng;
  }
  [((id<IMapView>) ((id<IMapView>) [self getView])) animateCameraBoundsWithILatLngBounds:bounds withInt:MapPresenter_DEFAULT_MAP_BOUNDS_PADDING_];
  return YES;
}

- (void)onMarkerClickWithMarkerModel:(MarkerModel *)markerModel {
  [((id<IMapView>) ((id<IMapView>) [self getView])) showInfoWindowForWithMarkerModel:markerModel];
}

- (void)onMarkerInfoWindowClickWithMarkerModel:(MarkerModel *)markerModel {
  Place *place = [markerModel getPlace];
  if ([self isPointOfInterestWithPlace:place]) {
    [((id<IMapView>) ((id<IMapView>) [self getView])) showInfoMessageWithNSString:mPoiClickMessage_];
  }
  else {
    [((id<IMapView>) ((id<IMapView>) [self getView])) showPlaceDetailViewWithPlace:[markerModel getPlace] withVanilaLocation:mCenter_];
  }
}

- (BOOL)isPointOfInterestWithPlace:(Place *)place {
  return place.placeId == nil;
}

- (void)onBackPressed {
  if (((id<IMapView>) [self getView]) == nil) {
    return;
  }
  [self resetMap];
  [((id<IMapView>) ((id<IMapView>) [self getView])) showCallerView];
  [super onBackPressed];
}

- (void)onDestroy {
  [self resetMap];
  mMarkerModelList_ = nil;
  mLocationApi_ = nil;
  mPendingCameraZoomUpdateLatLng_ = nil;
  mCenter_ = nil;
  mMarkers_ = nil;
  mCurrentTransaction_ = nil;
  mVisibleRegionLocations_ = nil;
  [super onDestroy];
}

+ (void)initialize {
  if (self == [MapPresenter class]) {
    MapPresenter_DEFAULT_MAP_BOUNDS_PADDING_ = 100;
  }
}

- (void)copyAllPropertiesTo:(id)copy {
  
  MapPresenter *typedCopy = (MapPresenter *) copy;
  typedCopy.mLocationApi = mLocationApi_;
  typedCopy.mIsMapLoading = mIsMapLoading_;
  typedCopy.mVeryFirstLoading = mVeryFirstLoading_;
  typedCopy.mMapAdjusted = mMapAdjusted_;
  typedCopy.mMarkerModelList = mMarkerModelList_;
  typedCopy.mCenter = mCenter_;
  typedCopy.mWaitingToRenderModel = mWaitingToRenderModel_;
  typedCopy.mVisibleRegionLocations = mVisibleRegionLocations_;
  typedCopy.mMarkers = mMarkers_;
  typedCopy.mPendingCameraZoomUpdateLatLng = mPendingCameraZoomUpdateLatLng_;
  typedCopy.mCameraOperationInProgress = mCameraOperationInProgress_;
  typedCopy.mCurrentZoomLevel = mCurrentZoomLevel_;
  typedCopy.mCurrentTransaction = mCurrentTransaction_;
  typedCopy.mPoiClickMessage = mPoiClickMessage_;
}

@end
@implementation MapPresenter_MapTransaction

@synthesize this$0 = this$0_;
@synthesize list = list_;
@synthesize placeMarkers = placeMarkers_;
@synthesize visiblePlaceLocations = visiblePlaceLocations_;
@synthesize animateCamera = animateCamera_;
@synthesize isProcessing = isProcessing_;

- (id)initWithMapPresenter:(MapPresenter *)outer$1
          withIGenericList:(id<IGenericList>)list {
  if ((self = [super init])) {
    this$0_ = outer$1;
    self.list = list;
    animateCamera_ = NO;
    placeMarkers_ = ((id<IGenericList>) [((id<IMobilePlatformFactory>) this$0_.mMobilePlatformFactory) newList]);
    visiblePlaceLocations_ = ((id<IGenericList>) [((id<IMobilePlatformFactory>) this$0_.mMobilePlatformFactory) newList]);
    isProcessing_ = YES;
  }
  return self;
}

- (void)commit {
  isProcessing_ = NO;
}

- (void)copyAllPropertiesTo:(id)copy {
  
  MapPresenter_MapTransaction *typedCopy = (MapPresenter_MapTransaction *) copy;
  typedCopy.this$0 = this$0_;
  typedCopy.list = list_;
  typedCopy.placeMarkers = placeMarkers_;
  typedCopy.visiblePlaceLocations = visiblePlaceLocations_;
  typedCopy.animateCamera = animateCamera_;
  typedCopy.isProcessing = isProcessing_;
}

@end
